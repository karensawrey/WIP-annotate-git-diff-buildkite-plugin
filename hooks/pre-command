#!/usr/bin/env bash
set -euo pipefail

# shellcheck source=lib/plugin.bash
. "$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )/../lib/plugin.bash"

# Get plugin configuration
PLUGIN_CONTEXT=$(plugin_read_config "CONTEXT" "git-diff")
PLUGIN_FORMAT=$(plugin_read_config "FORMAT" "markdown")
PLUGIN_COMPARE_BRANCH=$(plugin_read_config "COMPARE_BRANCH" "")  # Default to empty which is treated as current branch
PLUGIN_COMPARE_COMMITS=$(plugin_read_config "COMPARE_COMMITS" "1")
PLUGIN_INCLUDE_MERGE_BASE=$(plugin_read_config "INCLUDE_MERGE_BASE" "true")
PLUGIN_INCLUDE_SUBMODULES=$(plugin_read_config "INCLUDE_SUBMODULES" "false")
PLUGIN_COMPARE_PREVIOUS_BUILD=$(plugin_read_config "COMPARE_PREVIOUS_BUILD" "false")
PLUGIN_BUILDKITE_API_TOKEN=$(plugin_read_config "BUILDKITE_API_TOKEN" "")

# Get current SHA
CURRENT_SHA=${BUILDKITE_COMMIT}

# Set up git diff flags
DIFF_FLAGS=""
if [[ "${PLUGIN_INCLUDE_SUBMODULES}" == "true" ]]; then
    DIFF_FLAGS="--submodule=diff"
fi

if [[ "${PLUGIN_COMPARE_PREVIOUS_BUILD}" == "true" ]]; then
    # Validate if the API access token is present
    if [[ -z "${PLUGIN_BUILDKITE_API_TOKEN}" ]]; then
        echo "Error: BUILDKITE_API_TOKEN is required when compare_previous_build is true"
        exit 1
    fi


    # Fetch the last two passed builds on the branch, sorted by descending build number.
    # This returns the current build (if it's passed) and the immediately previous build. 
    # Altertnatively, I consider comparing "https://api.buildkite.com/v2/organizations/{org.slug}/pipelines/{pipeline.slug}/builds/{number}" 
    # to "https://api.buildkite.com/v2/organizations/{org.slug}/pipelines/{pipeline.slug}/builds/{number-minus-one}" - in that case 
    # the build number of the latest build should be passed manually in the plugin configuration in the Pipeline config 
    # alongside the API access token
    
    API_RESPONSE=$(curl -s -f -H "Authorization: Bearer ${PLUGIN_BUILDKITE_API_TOKEN}" \
        "https://api.buildkite.com/v2/organizations/${BUILDKITE_ORGANIZATION_SLUG}/pipelines/${BUILDKITE_PIPELINE_SLUG}/builds?&state=passed&per_page=2" || true)

    #Potentially, here for the build comparison it could be possible to disregard the complex way
    # and just get the webhook JSON payload and build the comparison based on the data in the MODIFIED field.
    # One way to do it is to get all the info on the modified field and output that in the annotation -
    # alternatively - compare it to the MODIFIED payload from the build number minus one.

    # Determine the previous build's commit SHA.
    # If the first build in the response is the current build, then select the second one.
    # Otherwise, use the first build.
    PREVIOUS_BUILD_SHA=$(echo "${API_RESPONSE}" | \
        jq -r --arg current "$BUILDKITE_BUILD_NUMBER" 'if (.[0].number | tostring) == $current then .[1].commit else .[0].commit end')

    if [[ -z "${PREVIOUS_BUILD_SHA}" || "${PREVIOUS_BUILD_SHA}" == "null" ]]; then
        buildkite-agent annotate "No previous successful build found on branch ${BUILDKITE_BRANCH}" \
            --context "${PLUGIN_CONTEXT}" \
            --style "warning" \
            --append
        exit 0
    fi

    # Validate that we can fetch the commit
    if ! git cat-file -e "${PREVIOUS_BUILD_SHA}^{commit}" 2>/dev/null; then
        echo "Fetching commit ${PREVIOUS_BUILD_SHA} from remote..."
        if ! git fetch origin "${PREVIOUS_BUILD_SHA}"; then
            buildkite-agent annotate "Error: Could not fetch commit ${PREVIOUS_BUILD_SHA}" \
                --context "${PLUGIN_CONTEXT}" \
                --style "error" \
                --append
            exit 1
        fi
    fi

    COMPARE_SHA=${PREVIOUS_BUILD_SHA}
elif [ -n "${PLUGIN_COMPARE_BRANCH}" ]; then
    # If compare_branch is set, fetch and compare against it
    git fetch origin "${PLUGIN_COMPARE_BRANCH}"
    TARGET_BRANCH_SHA=$(git rev-parse "origin/${PLUGIN_COMPARE_BRANCH}")

    if [[ "${PLUGIN_INCLUDE_MERGE_BASE}" == "true" ]]; then
        # Find the merge-base (common ancestor) between target branch and current commit
        COMPARE_SHA=$(git merge-base "${TARGET_BRANCH_SHA}" "${CURRENT_SHA}")
    else
        # Use the head of the target branch
        COMPARE_SHA=${TARGET_BRANCH_SHA}
    fi
else
    # If no compare_branch is set, compare against N commits back
    COMPARE_SHA=$(git rev-parse "${CURRENT_SHA}~${PLUGIN_COMPARE_COMMITS}")
fi

# Check if there are any changes
if [[ -z "$(git diff --numstat ${DIFF_FLAGS} "${COMPARE_SHA}" "${CURRENT_SHA}")" ]]; then
    if [[ "${PLUGIN_COMPARE_PREVIOUS_BUILD}" == "true" ]]; then
        buildkite-agent annotate "No changes found between previous build (${COMPARE_SHA:0:8}) and current build (${CURRENT_SHA:0:8})" \
            --context "${PLUGIN_CONTEXT}" \
            --style "info" \
            --append
    elif [ -n "${PLUGIN_COMPARE_BRANCH}" ]; then
        buildkite-agent annotate "No changes found between ${COMPARE_SHA:0:8} on ${PLUGIN_COMPARE_BRANCH} and ${CURRENT_SHA:0:8} on ${BUILDKITE_BRANCH}" \
            --context "${PLUGIN_CONTEXT}" \
            --style "info" \
            --append
    else
        if [[ "${PLUGIN_COMPARE_COMMITS}" -eq 1 ]]; then
            buildkite-agent annotate "No changes found between commits ${COMPARE_SHA:0:8} and ${CURRENT_SHA:0:8}" \
                --context "${PLUGIN_CONTEXT}" \
                --style "info" \
                --append
        else
            buildkite-agent annotate "No changes found in the last ${PLUGIN_COMPARE_COMMITS} commits (${COMPARE_SHA:0:8} to ${CURRENT_SHA:0:8})" \
                --context "${PLUGIN_CONTEXT}" \
                --style "info" \
                --append
        fi
    fi
    exit 0
fi

# Create temporary markdown file
TEMP_MD=$(mktemp)
trap 'rm -f "${TEMP_MD}"' EXIT

if [[ "${PLUGIN_FORMAT}" == "markdown" ]]; then
    # Add header
    if [[ "${PLUGIN_COMPARE_PREVIOUS_BUILD}" == "true" ]]; then
        HEADER="Comparing changes between previous build (${COMPARE_SHA:0:8}) and current build (${CURRENT_SHA:0:8})\n"
    elif [ -n "${PLUGIN_COMPARE_BRANCH}" ]; then
        HEADER="Comparing changes between ${COMPARE_SHA:0:8} on ${PLUGIN_COMPARE_BRANCH} to ${CURRENT_SHA:0:8} on ${BUILDKITE_BRANCH}\n"
    else
        if [[ "${PLUGIN_COMPARE_COMMITS}" -eq 1 ]]; then
            HEADER="Comparing changes between commits ${COMPARE_SHA:0:8} and ${CURRENT_SHA:0:8}\n"
        else
            HEADER="Comparing changes in the last ${PLUGIN_COMPARE_COMMITS} commits (${COMPARE_SHA:0:8} to ${CURRENT_SHA:0:8})\n"
        fi
    fi

    # shellcheck disable=SC2129
    echo -e "${HEADER}" >> "${TEMP_MD}"

    # Add diff with terminal colors
    {
        echo '```term'
        git diff --color=always ${DIFF_FLAGS} "${COMPARE_SHA}" "${CURRENT_SHA}"
        echo '```'
    } >> "${TEMP_MD}"

    # Add summary
    {
        echo
        echo "**Summary:** $(git diff --numstat ${DIFF_FLAGS} "${COMPARE_SHA}" "${CURRENT_SHA}" | awk '
            BEGIN { additions = 0; deletions = 0; files = 0 }
            {
                additions += $1;
                deletions += $2;
                files += 1
            }
            END {
                print files " files changed, " additions " insertions(+), " deletions " deletions(-)"
            }
        ')"
    } >> "${TEMP_MD}"
else
    # Raw diff format
    git diff --color=always ${DIFF_FLAGS} "${COMPARE_SHA}" "${CURRENT_SHA}" > "${TEMP_MD}"
fi

buildkite-agent annotate "$(cat "${TEMP_MD}")" \
    --context "${PLUGIN_CONTEXT}" \
    --style "info" \
    --append
